module adder_ram (
    input  wire clk,
    input  wire rst_n
);
    // Number of test pairs
    localparam N = 10;

    // --- Block RAM for inputs (a, b) ---
    reg [31:0] ram_a [0:N-1];
    reg [31:0] ram_b [0:N-1];

    // --- Block RAM for outputs (sum, cout) ---
    reg [32:0] ram_res [0:N-1];  // 32-bit sum + 1-bit cout

    // --- Signals ---
    reg [3:0] addr;     // Address counter (up to N)
    reg [31:0] a_reg, b_reg;
    reg cin_reg;

    wire [31:0] sum_wire;
    wire cout_wire;

    reg [1:0] state;

    // Instantiate the number_adder
    number_adder uut (
        .a(a_reg),
        .b(b_reg),
        .cin(cin_reg),
        .sum(sum_wire),
        .cout(cout_wire)
    );

    // FSM states
    localparam S_IDLE = 2'd0,
               S_READ = 2'd1,
               S_WRITE = 2'd2,
               S_DONE = 2'd3;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            addr <= 0;
            state <= S_IDLE;
        end else begin
            case (state)
                S_IDLE: begin
                    addr <= 0;
                    state <= S_READ;
                end

                S_READ: begin
                    // Load operands from BRAM
                    a_reg   <= ram_a[addr];
                    b_reg   <= ram_b[addr];
                    cin_reg <= 1'b0;  // fixed cin = 0 (you can change)
                    state   <= S_WRITE;
                end

                S_WRITE: begin
                    // Store results
                    ram_res[addr] <= {cout_wire, sum_wire};
                    if (addr == N-1)
                        state <= S_DONE;
                    else begin
                        addr <= addr + 1;
                        state <= S_READ;
                    end
                end

                S_DONE: begin
                    // Stay here after processing all inputs
                    state <= S_DONE;
                end
            endcase
        end
    end

    // --- Initialize input BRAM with some test values ---
    initial begin
        // Example test vectors
        ram_a[0] = 32'h0000_0001; ram_b[0] = 32'h0000_0002;
        ram_a[1] = 32'h0000_00AA; ram_b[1] = 32'h0000_00BB;
        ram_a[2] = 32'h1234_5678; ram_b[2] = 32'h1111_2222;
        ram_a[3] = 32'hFFFF_FFFF; ram_b[3] = 32'h0000_0001;
        ram_a[4] = 32'hAAAA_AAAA; ram_b[4] = 32'h5555_5555;
        ram_a[5] = 32'hDEAD_BEEF; ram_b[5] = 32'h0000_0001;
        ram_a[6] = 32'h0F0F_0F0F; ram_b[6] = 32'hF0F0_F0F0;
        ram_a[7] = 32'h1357_9BDF; ram_b[7] = 32'h2468_ACED;
        ram_a[8] = 32'h8000_0000; ram_b[8] = 32'h8000_0000;
        ram_a[9] = 32'h7FFF_FFFF; ram_b[9] = 32'h0000_0001;
    end

endmodule
